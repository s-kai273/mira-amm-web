#!/bin/sh

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
UNDERLINE='\033[4m'
NC='\033[0m'

DRY_RUN=true
STEP=1

while getopts "y" opt; do
  case $opt in
  y) DRY_RUN=false ;;
  *)
    echo -e "${RED}Usage: $0 [-y]${NC}"
    exit 1
    ;;
  esac
done

log_step() {
  HEADER_WIDTH=55
  TITLE="$1"
  STATUS="$2"
  MARK=""
  COLOR="${MAGENTA}"

  if [ "$STATUS" = "green" ]; then
    COLOR="${GREEN}"
    MARK=" ‚úÖ"
  fi

  TEXT="$STEP. $(echo "$TITLE" | tr '[:lower:]' '[:upper:]')$MARK"
  TEXT_LEN=${#TEXT}
  PADDING_WIDTH=$(((HEADER_WIDTH - TEXT_LEN - 2) / 2))
  LEFT_PADDING=$(printf '%*s' "$PADDING_WIDTH" '' | tr ' ' '=')
  RIGHT_PADDING=$LEFT_PADDING
  [ $((TEXT_LEN + 2 + ${#LEFT_PADDING} * 2)) -lt $HEADER_WIDTH ] && RIGHT_PADDING="${RIGHT_PADDING}="

  echo -e "${COLOR}$(printf '=%.0s' $(seq 1 $HEADER_WIDTH))${NC}"
  echo -e "${COLOR}${LEFT_PADDING} ${TEXT} ${RIGHT_PADDING}${NC}"
  echo -e "${COLOR}$(printf '=%.0s' $(seq 1 $HEADER_WIDTH))${NC}"
  STEP=$((STEP + 1))
}

run() {
  if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}$1${NC}"
  else
    echo -e "${CYAN}‚Ü™ Running: ${NC}$1"
    if ! eval "$1"; then
      echo -e "${RED}‚ùå Command failed: $1${NC}"
      return 1
    fi
  fi
}

confirm() {
  if [ "$DRY_RUN" = true ]; then
    return 0
  fi
  printf "%s [${GREEN}y${NC}/${RED}n${NC}]: " "$1"
  read -r response
  case "$response" in
  [Yy]) return 0 ;;
  [Nn]) return 1 ;;
  *)
    echo -e "${RED}Invalid input.${NC}"
    return 1
    ;;
  esac
}

check_and_report() {
  CMD="$1"
  DESC="$2"
  SUCCESS="$3"
  FAIL="$4"

  echo -e "üîç $DESC with command:"
  echo -e "    ${CYAN}${CMD}${NC}"
  if eval "$CMD" >/dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ $SUCCESS${NC}"
    return 0
  else
    echo -e "${RED}‚ùå $FAIL${NC}"
    return 1
  fi
}

detect_os() {
  if [ "$(uname)" = "Darwin" ]; then
    echo "macos"
  elif grep -qi "arch" /etc/os-release 2>/dev/null; then
    echo "arch"
  elif grep -qi "ubuntu" /etc/os-release 2>/dev/null; then
    echo "ubuntu"
  else
    echo "other"
  fi
}

print_system_info() {
  OS=$(detect_os)
  case $OS in
  macos) PKG="brew" ;;
  arch) PKG="pacman" ;;
  ubuntu) PKG="apt" ;;
  *) PKG="unknown" ;;
  esac

  echo
  echo -e "${CYAN}==========================================${NC}"
  echo -e "${BOLD}üéØ Detected OS:${NC}        $(echo "$OS" | tr '[:lower:]' '[:upper:]')"
  echo -e "${BOLD}üì¶ Package Manager:${NC}    $PKG"
  echo -e "${CYAN}==========================================${NC}"
  echo
}

# === STEP FUNCTIONS ===

step_install_direnv() {
  if command -v direnv >/dev/null 2>&1; then
    log_step "Install direnv" green
    check_and_report "command -v direnv" "Checking direnv installation" "direnv is already installed." "direnv is not installed."
    return
  else
    log_step "Install direnv"
  fi

  OS=$(detect_os)
  case $OS in
  macos) confirm "Install direnv via Homebrew?" && run "brew install direnv" ;;
  arch) confirm "Install direnv via pacman?" && run "sudo pacman -Syu direnv" ;;
  ubuntu) confirm "Install direnv via apt?" && run "sudo apt install -y direnv" ;;
  *) echo -e "${RED}Unsupported OS. Install manually: https://direnv.net/docs/installation.html${NC}" ;;
  esac
}

step_configure_direnv_hook() {
  SHELL_NAME=$(basename "$SHELL")
  RC_FILE="$HOME/.${SHELL_NAME}rc"
  HOOK="eval \"\$(direnv hook $SHELL_NAME)\""

  if grep -qxF "$HOOK" "$RC_FILE"; then
    log_step "Configure direnv hook" green
    echo -e "${GREEN}‚úÖ Direnv hook already exists in ${UNDERLINE}$RC_FILE${NC}"
    return
  else
    log_step "Configure direnv hook"
  fi

  confirm "Add direnv hook to $RC_FILE?" && run "echo '$HOOK' >> $RC_FILE"
  check_and_report "grep -qxF '$HOOK' '$RC_FILE'" "Verifying hook in $RC_FILE" "Hook added successfully." "Failed to add direnv hook."
}

step_install_nix() {
  if command -v nix >/dev/null 2>&1; then
    log_step "Install Nix" green
    check_and_report "command -v nix" "Checking Nix installation" "Nix is already installed." "Nix not installed."
    return
  else
    log_step "Install Nix"
  fi

  confirm "Install Nix via Determinate Systems script?" && run "curl -fsSL https://install.determinate.systems/nix | sh -s -- install || { echo 'Nix installation failed'; exit 1; }"
}

step_configure_nix_trusted_users() {
  NIX_CONF="/etc/nix/nix.custom.conf"
  TRUSTED_USERS="trusted-users = root $(whoami)"

  if grep -q "^$TRUSTED_USERS" "$NIX_CONF"; then
    log_step "Configure Nix trusted-users" green
    check_and_report "grep -q '^$TRUSTED_USERS' $NIX_CONF" "Checking trusted-users config" "trusted-users is configured in $NIX_CONF" "trusted-users entry not found."
    return
  else
    log_step "Configure Nix trusted-users"
  fi

  run "sudo sh -c 'echo $TRUSTED_USERS >> $NIX_CONF'"
}

step_restart_nix_daemon() {
  log_step "Restart Nix daemon"

  CMD="systemctl is-active --quiet nix-daemon"
  echo -e "üîç Checking nix-daemon status with command:"
  echo -e "    ${CYAN}${CMD}${NC}"

  if command -v systemctl >/dev/null 2>&1 && systemctl is-active --quiet nix-daemon; then
    echo -e "${GREEN}‚úÖ nix-daemon is currently running.${NC}"
  else
    echo -e "${YELLOW}‚ö†Ô∏è nix-daemon is not running or systemctl not available.${NC}"
  fi

  echo -e "${CYAN}‚Üª Restarting nix-daemon...${NC}"
  run "sudo systemctl restart nix-daemon"
}

step_install_devenv() {
  if command -v devenv >/dev/null 2>&1; then
    log_step "Install devenv" green
    check_and_report "command -v devenv" "Checking devenv" "devenv is already installed." "devenv not installed."
    return
  else
    log_step "Install devenv"
  fi

  confirm "Install devenv using nix-env?" && run "nix-env --install --attr devenv -f https://github.com/NixOS/nixpkgs/tarball/nixpkgs-unstable"
}

step_clone_repo() {
  REPO_NAME="mira-amm-web"
  if [ "$(basename "$(pwd)")" = "$REPO_NAME" ] && [ -d ".git" ]; then
    log_step "Already in project directory" green
    return
  fi

  log_step "Clone project repository"
  confirm "Fork and clone the repository?" && run "gh repo fork mira-amm/mira-amm-web --clone" && run "cd mira-amm-web"
}

step_enable_direnv() {
  log_step "Enable direnv in project"
  confirm "Allow direnv in this project?" && run "direnv allow"
}

step_install_playwright() {
  CMD="pnpm exec playwright --version"

  if eval "$CMD" >/dev/null 2>&1; then
    log_step "Install Playwright browsers"
    echo -e "üîç Checking for Playwright CLI with command:"
    echo -e "    ${CYAN}${CMD}${NC}"
    echo -e "${GREEN}‚úÖ Playwright CLI detected.${NC}"
    confirm "Install Playwright browsers?" && run "pnpm exec playwright install --with-deps"
  else
    log_step "Install Playwright browsers" green
    echo -e "${YELLOW}‚ö†Ô∏è Playwright not found via pnpm. Skipping browser install.${NC}"
    echo -e "üí° You may need to run: ${CYAN}pnpm add -D @playwright/test${NC}"
  fi
}

step_finish() {
  if [ "$DRY_RUN" = true ]; then
    log_step "Dry run complete. Re-run with -y to execute"
  else
    log_step "Setup complete! Restarting your shell..."
    echo "ü§ñ running 'exec \$SHELL'"
    exec $SHELL
  fi
}

# === STEP REGISTRY ===

STEPS="
  step_install_direnv
  step_configure_direnv_hook
  step_install_nix
  step_configure_nix_trusted_users
  step_restart_nix_daemon
  step_install_devenv
  step_clone_repo
  step_enable_direnv
  step_install_playwright
  step_finish
"

# === EXECUTE STEPS ===
print_system_info

for step in $STEPS; do
  $step
done
